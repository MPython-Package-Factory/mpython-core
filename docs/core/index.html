<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>mpython.core API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mpython.core</code></h1>
</header>
<section id="section-intro">
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="mpython.core.base_types" href="base_types.html">mpython.core.base_types</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="mpython.core.delayed_types" href="delayed_types.html">mpython.core.delayed_types</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="mpython.core.mixin_types" href="mixin_types.html">mpython.core.mixin_types</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="mpython.core.wrapped_types" href="wrapped_types.html">mpython.core.wrapped_types</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mpython.core.AnyDelayedArray"><code class="flex name class">
<span>class <span class="ident">AnyDelayedArray</span></span>
<span>(</span><span>parent, *index)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnyDelayedArray(AnyMatlabArray):
    &#34;&#34;&#34;
    This is an object that we return when we don&#39;t know how an indexed
    element will be used yet.

    It decides whether it is a Struct, Cell or Array based on the
    type of indexing that is used.

    In Matlab:

    * `a(x,y)   = num`  indicates that `a` is a numeric array;
    * `a(x,y)   = cell` indicates that `a` is a cell array;
    * `a{x,y}   = any`  indicates that `a` is a cell array;
    * `a(x,y).f = any`  indicates that `a` is a struct array;
    * `a.f      = any`  indicates that `a` is a struct.

    These indexing operations can be chained, so in
    `a(x).b.c{y}.d(z) = 2`:

    * `a`    is a struct array;
    * `b`    is a struct;
    * `c`    is a cell;
    * `c{y}` is a struct
    * `d`    is a numeric array.

    In Python, there is only one type of indexing (`[]`). This is a problem as
    we cannot differentiate `a{x}.b = y` — where `a` is a cell that contains
    a struct — from `a(x).b = y` — where `a` is a struct array.

    One solution may be to abuse the &#34;call&#34; operator `()`, so that it returns a
    cell. This would work in some situations (`a[x].b = y` is a struct array,
    whereas `a(x).b = y` is a cell of struct). However, the statement
    `a(x) = y` (which would correspond to matlab&#39;s `a{x} = y`) is not valid
    python syntax. Furthermore, it would induce a new problem, as cells could
    not be differentiated from function handles, in some cases.

    Instead, the use of brackets automatically transforms the object into
    either:

    * a `Struct` (in all &#34;get&#34; cases, and in the &#34;set&#34; context `a[x] = y`,
      when `y` is either a `dict` or a `Struct`); or
    * an `Array` (in the &#34;set&#34; context `a[x] = y`, when `y` is neither a
      `dict` nor a `Struct`).

    Alternatively, if the user wishes to specify which type the object should
    take, we implement the properties `as_cell`, `as_struct` and `as_num`.

    Therefore:

    * `a[x,y]             = num`    : `a` is a numeric array;
    * `a[x,y]             = struct` : `a` is a numeric array;
    * `a[x,y].f           = any`    : `a` is a struct array;
    * `a(x,y).f           = any`    : `a` is a cell array containing a struct;
    * `a.f                = any`    : `a` is a struct.

    And explictly:

    * `a.as_cell[x,y]     = any`    : `a` is a cell array;
    * `a.as_struct[x,y].f = any`    : `a` is a struct array;
    * `a.as_cell[x,y].f   = any`    : `a` is a cell array containing a struct;
    * `a.as_num[x,y]      = num`    : `a` is a numeric array.
    &#34;&#34;&#34;

    _ATTRIBUTES = (&#34;_parent&#34;, &#34;_index&#34;, &#34;_future&#34;, &#34;_finalized&#34;)

    def __init__(self, parent, *index):
        &#34;&#34;&#34;
        Parameters
        ----------
        parent : ndarray | dict
            Reference to the object that will eventually contain
            this element.

            * If the containing array is a `Cell`, `parent` should be a
              `ndarray` view of that cell, and `index` should be a
              [tuple of] int.
            * If the containing array is a `Struct`, `parent` should be a
              `dict`, and `index` should be a string.
        index : str | [tuple of] int
            Index into the parent where this element will be inserted.
        &#34;&#34;&#34;
        super().__init__()
        self._parent = parent  # reference to parent container
        self._index = index  # index into parent container
        self._future = None  # future array
        self._finalized = False  # whether this array has been finalized

    @property
    def _final(self):
        self._finalize()
        return self._future

    def _finalize(self):
        if self._finalized:
            return

        if self._future is None:
            # FIXME: I am not entirely sure this should ever happen
            self._future = _empty_array()

        # if future array is wrapped, unwrap it
        if isinstance(self._future, WrappedDelayedArray):
            self._future = self._future._future
            if hasattr(self._future, &#34;_delayed_wrapper&#34;):
                del self._future._delayed_wrapper

        # set value in parent
        parent = self._parent
        for index in self._index[:-1]:
            parent = parent[index]
        parent[self._index[-1]] = self._future

        # finalize parent if needed
        if hasattr(self._parent, &#34;_final&#34;):
            self._parent = self._parent._final

        self._finalized = True

    def _error_is_not_finalized(self, *args, **kwargs):
        raise IndexOrKeyOrAttributeError(
            &#34;This DelayedArray has not been finalized, and you are &#34;
            &#34;attempting to use it in a way that may break its finalization &#34;
            &#34;cycle. It most likely means that you are indexing out-of-bounds &#34;
            &#34;without *setting* the out-of-bound value. &#34;
            &#34;Correct usage: `a.b(i).c = x` | Incorrect usage: `x = a.b(i).c`.&#34;
        )

    # Kill all operators
    __str__ = __repr__ = _error_is_not_finalized
    __bool__ = __float__ = __int__ = _error_is_not_finalized
    __ceil__ = __floor__ = __round__ = __trunc__ = _error_is_not_finalized
    __add__ = __iadd__ = __radd__ = _error_is_not_finalized
    __sub__ = __isub__ = __rsub__ = _error_is_not_finalized
    __mul__ = __imul__ = __rmul__ = _error_is_not_finalized
    __truediv___ = __itruediv___ = __rtruediv___ = _error_is_not_finalized
    __floordiv___ = __ifloordiv___ = __rfloordiv___ = _error_is_not_finalized
    __eq__ = __ne__ = _error_is_not_finalized
    __gt__ = __ge__ = __lt__ = __le__ = _error_is_not_finalized
    __abs__ = __neg__ = __pos__ = _error_is_not_finalized
    __pow__ = __ipow__ = __rpow__ = _error_is_not_finalized
    __mod__ = __imod__ = __rmod__ = _error_is_not_finalized
    __divmod__ = __idivmod__ = __rdivmod__ = _error_is_not_finalized
    __contains__ = _error_is_not_finalized

    def __getattribute__(self, name):
        # Do not allow any attribute to be accessed except for those
        # explicitly allowed by the AnyDelayedArray class.
        # This is so no &#34;computation&#34; is peformed on DelayedCell,
        # DelayedStruct, etc.
        if name.startswith(&#34;_&#34;):
            return super().__getattribute__(name)
        if name not in self.__dict__ and name not in AnyDelayedArray.__dict__:
            return self._error_is_not_finalized()
        return super().__getattribute__(name)

    # --- Promise type -------------------------------------------------

    @property
    def as_cell(self) -&gt; &#34;DelayedCell&#34;:
        if self._future is None:
            self._future = DelayedCell((), self._parent, *self._index)
        if not isinstance(self._future, DelayedCell):
            raise TypeError(
                f&#34;{type(self._future)} cannot be interpreted as a Cell&#34;
            )
        return self._future

    @property
    def as_struct(self) -&gt; &#34;DelayedStruct&#34;:
        if self._future is None:
            self._future = DelayedStruct((), self._parent, *self._index)
        if not isinstance(self._future, DelayedStruct):
            raise TypeError(
                f&#34;{type(self._future)} cannot be interpreted as a Struct&#34;
            )
        return self._future

    @property
    def as_num(self) -&gt; &#34;DelayedArray&#34;:
        if self._future is None:
            self._future = DelayedArray([0], self._parent, *self._index)
        if not isinstance(self._future, DelayedArray):
            raise TypeError(
                f&#34;{type(self._future)} cannot be interpreted as a Array&#34;
            )
        return self._future

    def as_obj(self, obj):
        MatlabClass = _imports.MatlabClass
        if (
            self._future is not None and
            not isinstance(self._future, MatlabClass)
        ):
            raise TypeError(
                f&#34;{type(self._future)} cannot be interpreted as a {type(obj)}&#34;
            )
        self._future = obj
        return self._future

    # --- Guess promised type ------------------------------------------

    def __call__(self, *index):
        return self.as_cell(*index)

    def __getitem__(self, index):
        return self.as_struct[index]

    def __getattr__(self, key):
        return self.as_struct[key]

    def __setitem__(self, index, value):
        Array = _imports.Array
        Cell = _imports.Cell
        MatlabClass = _imports.MatlabClass
        Struct = _imports.Struct

        if isinstance(index, str):
            arr = self.as_struct

        elif isinstance(value, MatlabClass):
            if index not in (0, -1):
                raise NotImplementedError(
                    &#34;Implicit advanced indexing not implemented for&#34;,
                    type(value)
                )
            self.as_obj(value)
            return self._finalize()

        elif isinstance(value, (dict, Struct)):
            arr = self.as_struct
        elif isinstance(value, (tuple, list, set, Cell)):
            arr = self.as_cell
        elif isinstance(value, (int, float, np.number, Array)):
            arr = self.as_num
        elif isinstance(value, np.ndarray):
            if issubclass(value.dtype.type, np.number):
                arr = self.as_num
            else:
                arr = self.as_cell
        else:
            arr = self.as_cell

        arr[index] = value
        return self._finalize()  # Setter -&gt; we can trigger finalize

    def __setattr__(self, key, value):
        if key in type(self)._ATTRIBUTES:
            return super().__setattr__(key, value)
        self.as_struct[key] = value
        return self._finalize()  # Setter -&gt; we can trigger finalize</code></pre>
</details>
<div class="desc"><p>This is an object that we return when we don't know how an indexed
element will be used yet.</p>
<p>It decides whether it is a Struct, Cell or Array based on the
type of indexing that is used.</p>
<p>In Matlab:</p>
<ul>
<li><code>a(x,y)
= num</code>
indicates that <code>a</code> is a numeric array;</li>
<li><code>a(x,y)
= cell</code> indicates that <code>a</code> is a cell array;</li>
<li><code>a{x,y}
= any</code>
indicates that <code>a</code> is a cell array;</li>
<li><code>a(x,y).f = any</code>
indicates that <code>a</code> is a struct array;</li>
<li><code>a.f
= any</code>
indicates that <code>a</code> is a struct.</li>
</ul>
<p>These indexing operations can be chained, so in
<code>a(x).b.c{y}.d(z) = 2</code>:</p>
<ul>
<li><code>a</code>
is a struct array;</li>
<li><code>b</code>
is a struct;</li>
<li><code>c</code>
is a cell;</li>
<li><code>c{y}</code> is a struct</li>
<li><code>d</code>
is a numeric array.</li>
</ul>
<p>In Python, there is only one type of indexing (<code>[]</code>). This is a problem as
we cannot differentiate <code>a{x}.b = y</code> — where <code>a</code> is a cell that contains
a struct — from <code>a(x).b = y</code> — where <code>a</code> is a struct array.</p>
<p>One solution may be to abuse the "call" operator <code>()</code>, so that it returns a
cell. This would work in some situations (<code>a[x].b = y</code> is a struct array,
whereas <code>a(x).b = y</code> is a cell of struct). However, the statement
<code>a(x) = y</code> (which would correspond to matlab's <code>a{x} = y</code>) is not valid
python syntax. Furthermore, it would induce a new problem, as cells could
not be differentiated from function handles, in some cases.</p>
<p>Instead, the use of brackets automatically transforms the object into
either:</p>
<ul>
<li>a <code>Struct</code> (in all "get" cases, and in the "set" context <code>a[x] = y</code>,
when <code>y</code> is either a <code>dict</code> or a <code>Struct</code>); or</li>
<li>an <code>Array</code> (in the "set" context <code>a[x] = y</code>, when <code>y</code> is neither a
<code>dict</code> nor a <code>Struct</code>).</li>
</ul>
<p>Alternatively, if the user wishes to specify which type the object should
take, we implement the properties <code>as_cell</code>, <code>as_struct</code> and <code>as_num</code>.</p>
<p>Therefore:</p>
<ul>
<li><code>a[x,y]
= num</code>
: <code>a</code> is a numeric array;</li>
<li><code>a[x,y]
= struct</code> : <code>a</code> is a numeric array;</li>
<li><code>a[x,y].f
= any</code>
: <code>a</code> is a struct array;</li>
<li><code>a(x,y).f
= any</code>
: <code>a</code> is a cell array containing a struct;</li>
<li><code>a.f
= any</code>
: <code>a</code> is a struct.</li>
</ul>
<p>And explictly:</p>
<ul>
<li><code>a.as_cell[x,y]
= any</code>
: <code>a</code> is a cell array;</li>
<li><code>a.as_struct[x,y].f = any</code>
: <code>a</code> is a struct array;</li>
<li><code>a.as_cell[x,y].f
= any</code>
: <code>a</code> is a cell array containing a struct;</li>
<li><code>a.as_num[x,y]
= num</code>
: <code>a</code> is a numeric array.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>ndarray | dict</code></dt>
<dd>
<p>Reference to the object that will eventually contain
this element.</p>
<ul>
<li>If the containing array is a <code>Cell</code>, <code>parent</code> should be a
<code>ndarray</code> view of that cell, and <code>index</code> should be a
[tuple of] int.</li>
<li>If the containing array is a <code>Struct</code>, <code>parent</code> should be a
<code>dict</code>, and <code>index</code> should be a string.</li>
</ul>
</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>str | [tuple of] int</code></dt>
<dd>Index into the parent where this element will be inserted.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mpython.core.base_types.AnyMatlabArray" href="base_types.html#mpython.core.base_types.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="mpython.core.base_types.MatlabType" href="base_types.html#mpython.core.base_types.MatlabType">MatlabType</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpython.core.delayed_types.WrappedDelayedArray" href="delayed_types.html#mpython.core.delayed_types.WrappedDelayedArray">WrappedDelayedArray</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mpython.core.AnyDelayedArray.as_cell"><code class="name">prop <span class="ident">as_cell</span> : <a title="mpython.core.DelayedCell" href="#mpython.core.DelayedCell">DelayedCell</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_cell(self) -&gt; &#34;DelayedCell&#34;:
    if self._future is None:
        self._future = DelayedCell((), self._parent, *self._index)
    if not isinstance(self._future, DelayedCell):
        raise TypeError(
            f&#34;{type(self._future)} cannot be interpreted as a Cell&#34;
        )
    return self._future</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="mpython.core.AnyDelayedArray.as_num"><code class="name">prop <span class="ident">as_num</span> : <a title="mpython.core.DelayedArray" href="#mpython.core.DelayedArray">DelayedArray</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_num(self) -&gt; &#34;DelayedArray&#34;:
    if self._future is None:
        self._future = DelayedArray([0], self._parent, *self._index)
    if not isinstance(self._future, DelayedArray):
        raise TypeError(
            f&#34;{type(self._future)} cannot be interpreted as a Array&#34;
        )
    return self._future</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="mpython.core.AnyDelayedArray.as_struct"><code class="name">prop <span class="ident">as_struct</span> : <a title="mpython.core.DelayedStruct" href="#mpython.core.DelayedStruct">DelayedStruct</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_struct(self) -&gt; &#34;DelayedStruct&#34;:
    if self._future is None:
        self._future = DelayedStruct((), self._parent, *self._index)
    if not isinstance(self._future, DelayedStruct):
        raise TypeError(
            f&#34;{type(self._future)} cannot be interpreted as a Struct&#34;
        )
    return self._future</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mpython.core.AnyDelayedArray.as_obj"><code class="name flex">
<span>def <span class="ident">as_obj</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_obj(self, obj):
    MatlabClass = _imports.MatlabClass
    if (
        self._future is not None and
        not isinstance(self._future, MatlabClass)
    ):
        raise TypeError(
            f&#34;{type(self._future)} cannot be interpreted as a {type(obj)}&#34;
        )
    self._future = obj
    return self._future</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mpython.core.base_types.AnyMatlabArray" href="base_types.html#mpython.core.base_types.AnyMatlabArray">AnyMatlabArray</a></b></code>:
<ul class="hlist">
<li><code><a title="mpython.core.base_types.AnyMatlabArray.from_any" href="base_types.html#mpython.core.base_types.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mpython.core.AnyMatlabArray"><code class="flex name class">
<span>class <span class="ident">AnyMatlabArray</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnyMatlabArray(MatlabType):
    &#34;&#34;&#34;Base class for all matlab-like arrays (numeric, cell, struct).&#34;&#34;&#34;

    @property
    def as_num(self):
        raise TypeError(
            f&#34;Cannot interpret a {type(self).__name__} as a numeric array&#34;
        )

    @property
    def as_cell(self):
        raise TypeError(
            f&#34;Cannot interpret a {type(self).__name__} as a cell&#34;
        )

    @property
    def as_struct(self):
        raise TypeError(
            f&#34;Cannot interpret a {type(self).__name__} as a struct&#34;
        )

    # TODO: `as_obj` for object arrays?</code></pre>
</details>
<div class="desc"><p>Base class for all matlab-like arrays (numeric, cell, struct).</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mpython.core.base_types.MatlabType" href="base_types.html#mpython.core.base_types.MatlabType">MatlabType</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpython.core.delayed_types.AnyDelayedArray" href="delayed_types.html#mpython.core.delayed_types.AnyDelayedArray">AnyDelayedArray</a></li>
<li><a title="mpython.core.wrapped_types.AnyWrappedArray" href="wrapped_types.html#mpython.core.wrapped_types.AnyWrappedArray">AnyWrappedArray</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mpython.core.AnyMatlabArray.as_cell"><code class="name">prop <span class="ident">as_cell</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_cell(self):
    raise TypeError(
        f&#34;Cannot interpret a {type(self).__name__} as a cell&#34;
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="mpython.core.AnyMatlabArray.as_num"><code class="name">prop <span class="ident">as_num</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_num(self):
    raise TypeError(
        f&#34;Cannot interpret a {type(self).__name__} as a numeric array&#34;
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="mpython.core.AnyMatlabArray.as_struct"><code class="name">prop <span class="ident">as_struct</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_struct(self):
    raise TypeError(
        f&#34;Cannot interpret a {type(self).__name__} as a struct&#34;
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mpython.core.base_types.MatlabType" href="base_types.html#mpython.core.base_types.MatlabType">MatlabType</a></b></code>:
<ul class="hlist">
<li><code><a title="mpython.core.base_types.MatlabType.from_any" href="base_types.html#mpython.core.base_types.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mpython.core.AnyWrappedArray"><code class="flex name class">
<span>class <span class="ident">AnyWrappedArray</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnyWrappedArray(AnyMatlabArray):
    &#34;&#34;&#34;Base class for wrapped numpy/scipy arrays.&#34;&#34;&#34;

    @classmethod
    def _parse_args(cls, *args, **kwargs):
        &#34;&#34;&#34;
        This function is used in the `__new__` constructor of
        Array/Cell/Struct.

        It does some preliminary preprocesing to reduces the number of
        cases that must be handled by `__new__`.

        In particular:

        * It converts multiple integer arguments to a single list[int]
        * It extracts the shape or object to copy, if there is one.
        * It convert positional dtype/order into keywords.

        Returns
        -------
        mode : {&#34;shape&#34;, &#34;obj&#34;}
        arg : array-like | list[int]
        kwargs : dict
        &#34;&#34;&#34;
        __has_dtype = kwargs.pop(&#34;__has_dtype&#34;, True)
        __has_order = kwargs.pop(&#34;__has_order&#34;, True)

        # Detect integer arguments
        args, shape, obj = list(args), [], None
        while args and isinstance(args[0], int):
            shape.append(args.pop(0))

        # If no integer arguments, the first argument (if it exists)
        # must be a shape or an array-like object to convert.
        if not shape:
            # Catch case where no size/array is passed and the first
            # argument is a data type.
            if args and not isinstance(args[0], (str, np.dtype, type)):
                obj = args.pop(0)

        # If there are positional arguments remaining, they are:
        # 1. dtype
        if args and __has_dtype:
            if &#34;dtype&#34; in kwargs:
                raise TypeError(
                    f&#34;{cls.__name__}() got multiple values for argument &#34;
                    f&#34;&#39;dtype&#39;&#34;
                )
            kwargs[&#34;dtype&#34;] = args.pop(0)
        # 2. order {&#34;C&#34;, &#34;F&#34;}
        if args and __has_order:
            if &#34;order&#34; in kwargs:
                raise TypeError(
                    f&#34;{cls.__name__}() got multiple values for argument &#34;
                    f&#34;&#39;order&#39;&#34;
                )
            kwargs[&#34;order&#34;] = args.pop(0)
        # 3. no other positionals allowed -&gt; raise
        if args:
            raise TypeError(
                f&#34;{cls.__name__}() takes from 1 to 3 positional &#34;
                &#34;arguments but more were given&#34;
            )

        # If we found an object and it is a generator
        # (= an iterable that has no `len`), copy its values into a list.
        if hasattr(obj, &#34;__iter__&#34;) and not hasattr(obj, &#34;__len__&#34;):
            # save iterator values in a list
            obj = list(obj)

        # If obj is a list[int] -&gt; it is a shape
        if (
            not shape
            and isinstance(obj, (list, tuple))
            and all(isinstance(x, int) for x in obj)
        ):
            shape, obj = obj, None

        mode = &#34;obj&#34; if obj is not None else &#34;shape&#34;
        arg = obj if obj is not None else shape
        return mode, arg, kwargs</code></pre>
</details>
<div class="desc"><p>Base class for wrapped numpy/scipy arrays.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mpython.core.base_types.AnyMatlabArray" href="base_types.html#mpython.core.base_types.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="mpython.core.base_types.MatlabType" href="base_types.html#mpython.core.base_types.MatlabType">MatlabType</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpython.core.wrapped_types.WrappedArray" href="wrapped_types.html#mpython.core.wrapped_types.WrappedArray">WrappedArray</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mpython.core.base_types.AnyMatlabArray" href="base_types.html#mpython.core.base_types.AnyMatlabArray">AnyMatlabArray</a></b></code>:
<ul class="hlist">
<li><code><a title="mpython.core.base_types.AnyMatlabArray.from_any" href="base_types.html#mpython.core.base_types.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mpython.core.DelayedArray"><code class="flex name class">
<span>class <span class="ident">DelayedArray</span></span>
<span>(</span><span>shape, parent, *index)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DelayedArray(WrappedDelayedArray):
    &#34;&#34;&#34;
    An `Array` that will insert itself in its parent later.

    See `AnyDelayedArray`.
    &#34;&#34;&#34;

    def __init__(self, shape, parent, *index):
        &#34;&#34;&#34;
        Parameters
        ----------
        shape : list[int]
            Shape of the future numeric array.
        parent : Struct | Cell | AnyDelayedArray
            Parent object that contains the future object.
        *index : int | str
            Index of the future object in its parent.
        &#34;&#34;&#34;
        Array = _imports.Array
        future = Array.from_shape(shape)
        future._delayed_wrapper = self
        super().__init__(future, parent, *index)</code></pre>
</details>
<div class="desc"><p>An <code>Array</code> that will insert itself in its parent later.</p>
<p>See <code><a title="mpython.core.AnyDelayedArray" href="#mpython.core.AnyDelayedArray">AnyDelayedArray</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>Shape of the future numeric array.</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>Struct | Cell | AnyDelayedArray</code></dt>
<dd>Parent object that contains the future object.</dd>
<dt><strong><code>*index</code></strong> :&ensp;<code>int | str</code></dt>
<dd>Index of the future object in its parent.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mpython.core.delayed_types.WrappedDelayedArray" href="delayed_types.html#mpython.core.delayed_types.WrappedDelayedArray">WrappedDelayedArray</a></li>
<li><a title="mpython.core.delayed_types.AnyDelayedArray" href="delayed_types.html#mpython.core.delayed_types.AnyDelayedArray">AnyDelayedArray</a></li>
<li><a title="mpython.core.base_types.AnyMatlabArray" href="base_types.html#mpython.core.base_types.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="mpython.core.base_types.MatlabType" href="base_types.html#mpython.core.base_types.MatlabType">MatlabType</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mpython.core.delayed_types.WrappedDelayedArray" href="delayed_types.html#mpython.core.delayed_types.WrappedDelayedArray">WrappedDelayedArray</a></b></code>:
<ul class="hlist">
<li><code><a title="mpython.core.delayed_types.WrappedDelayedArray.from_any" href="base_types.html#mpython.core.base_types.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mpython.core.DelayedCell"><code class="flex name class">
<span>class <span class="ident">DelayedCell</span></span>
<span>(</span><span>shape, parent, *index)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DelayedCell(WrappedDelayedArray):
    &#34;&#34;&#34;
    A `Cell` that will insert itself in its parent later.

    See `AnyDelayedArray`.
    &#34;&#34;&#34;

    def __init__(self, shape, parent, *index):
        &#34;&#34;&#34;
        Parameters
        ----------
        shape : list[int]
            Shape of the future cell array.
        parent : Struct | Cell | AnyDelayedArray
            Parent object that contains the future object.
        *index : int | str
            Index of the future object in its parent.
        &#34;&#34;&#34;
        Cell = _imports.Cell
        future = Cell.from_shape(shape)
        future._delayed_wrapper = self
        super().__init__(future, parent, *index)

        # Insert delayed arrays instead of the usual defaults
        opt = dict(
            flags=[&#34;refs_ok&#34;, &#34;zerosize_ok&#34;, &#34;multi_index&#34;],
            op_flags=[&#34;writeonly&#34;, &#34;no_broadcast&#34;],
        )
        arr = np.ndarray.view(self._future, np.ndarray)
        with np.nditer(arr, **opt) as iter:
            for elem in iter:
                elem[()] = AnyDelayedArray(self, iter.multi_index)</code></pre>
</details>
<div class="desc"><p>A <code>Cell</code> that will insert itself in its parent later.</p>
<p>See <code><a title="mpython.core.AnyDelayedArray" href="#mpython.core.AnyDelayedArray">AnyDelayedArray</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>Shape of the future cell array.</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>Struct | Cell | AnyDelayedArray</code></dt>
<dd>Parent object that contains the future object.</dd>
<dt><strong><code>*index</code></strong> :&ensp;<code>int | str</code></dt>
<dd>Index of the future object in its parent.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mpython.core.delayed_types.WrappedDelayedArray" href="delayed_types.html#mpython.core.delayed_types.WrappedDelayedArray">WrappedDelayedArray</a></li>
<li><a title="mpython.core.delayed_types.AnyDelayedArray" href="delayed_types.html#mpython.core.delayed_types.AnyDelayedArray">AnyDelayedArray</a></li>
<li><a title="mpython.core.base_types.AnyMatlabArray" href="base_types.html#mpython.core.base_types.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="mpython.core.base_types.MatlabType" href="base_types.html#mpython.core.base_types.MatlabType">MatlabType</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mpython.core.delayed_types.WrappedDelayedArray" href="delayed_types.html#mpython.core.delayed_types.WrappedDelayedArray">WrappedDelayedArray</a></b></code>:
<ul class="hlist">
<li><code><a title="mpython.core.delayed_types.WrappedDelayedArray.from_any" href="base_types.html#mpython.core.base_types.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mpython.core.DelayedStruct"><code class="flex name class">
<span>class <span class="ident">DelayedStruct</span></span>
<span>(</span><span>shape, parent, *index)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DelayedStruct(WrappedDelayedArray):
    &#34;&#34;&#34;
    A `Struct` that will insert itself in its parent later.

    See `AnyDelayedArray`.
    &#34;&#34;&#34;

    def __init__(self, shape, parent, *index):
        &#34;&#34;&#34;
        Parameters
        ----------
        shape : list[int]
            Shape of the future struct array.
        parent : Struct | Cell | AnyDelayedArray
            Parent object that contains the future object.
        *index : int | str
            Index of the future object in its parent.
        &#34;&#34;&#34;
        Struct = _imports.Struct
        future = Struct.from_shape(shape)
        future._delayed_wrapper = self
        super().__init__(future, parent, *index)</code></pre>
</details>
<div class="desc"><p>A <code>Struct</code> that will insert itself in its parent later.</p>
<p>See <code><a title="mpython.core.AnyDelayedArray" href="#mpython.core.AnyDelayedArray">AnyDelayedArray</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>Shape of the future struct array.</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>Struct | Cell | AnyDelayedArray</code></dt>
<dd>Parent object that contains the future object.</dd>
<dt><strong><code>*index</code></strong> :&ensp;<code>int | str</code></dt>
<dd>Index of the future object in its parent.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mpython.core.delayed_types.WrappedDelayedArray" href="delayed_types.html#mpython.core.delayed_types.WrappedDelayedArray">WrappedDelayedArray</a></li>
<li><a title="mpython.core.delayed_types.AnyDelayedArray" href="delayed_types.html#mpython.core.delayed_types.AnyDelayedArray">AnyDelayedArray</a></li>
<li><a title="mpython.core.base_types.AnyMatlabArray" href="base_types.html#mpython.core.base_types.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="mpython.core.base_types.MatlabType" href="base_types.html#mpython.core.base_types.MatlabType">MatlabType</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mpython.core.delayed_types.WrappedDelayedArray" href="delayed_types.html#mpython.core.delayed_types.WrappedDelayedArray">WrappedDelayedArray</a></b></code>:
<ul class="hlist">
<li><code><a title="mpython.core.delayed_types.WrappedDelayedArray.from_any" href="base_types.html#mpython.core.base_types.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mpython.core.MatlabType"><code class="flex name class">
<span>class <span class="ident">MatlabType</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MatlabType:
    &#34;&#34;&#34;Generic type for objects that have an exact matlab equivalent.&#34;&#34;&#34;

    @classmethod
    def from_any(cls, other, **kwargs):
        &#34;&#34;&#34;
        Convert python/matlab objects to `MatlabType` objects
        (`Cell`, `Struct`, `Array`, `MatlabClass`).

        !!! warning &#34;Conversion is performed in-place when possible.&#34;
        &#34;&#34;&#34;
        # Circular import
        Array = _imports.Array
        Cell = _imports.Cell
        MatlabClass = _imports.MatlabClass
        MatlabFunction = _imports.MatlabFunction
        SparseArray = _imports.SparseArray
        Struct = _imports.Struct
        AnyDelayedArray = _imports.AnyDelayedArray

        # Conversion rules:
        # - we do not convert to matlab&#39;s own array types
        #   (`matlab.double`, etc);
        # - we do not convert to types that can be passed directly to
        #   the matlab runtime;
        # - instead, we convert to python types that mimic matlab types.
        _from_any = partial(cls.from_any, **kwargs)
        _runtime = kwargs.pop(&#34;_runtime&#34;, None)

        if isinstance(other, MatlabType):
            if isinstance(other, AnyDelayedArray):
                other._error_is_not_finalized()
            return other

        if isinstance(other, dict):
            if &#34;type__&#34; in other:
                type__ = other[&#34;type__&#34;]

                if type__ == &#34;none&#34;:
                    # MPython returns this when catching a function
                    # that should return no values but is asked for one.
                    return None

                elif type__ == &#34;emptystruct&#34;:
                    return Struct.from_shape([0])

                elif type__ == &#34;structarray&#34;:
                    # MPython returns a list of dictionaries in data__
                    # and the array shape in size__.
                    return Struct._from_runtime(other, _runtime)

                elif type__ == &#34;cell&#34;:
                    # MPython returns a list of dictionaries in data__
                    # and the array shape in size__.
                    return Cell._from_runtime(other, _runtime)

                elif type__ == &#34;object&#34;:
                    # MPython returns the object&#39;s fields serialized
                    # in a dictionary.
                    return MatlabClass._from_runtime(other, _runtime)

                elif type__ == &#34;sparse&#34;:
                    # MPython returns the coordinates and values in a dict.
                    return SparseArray._from_runtime(other, _runtime)

                elif type__ == &#34;char&#34;:
                    # Character array that is not a row vector
                    # (row vector are converted to str automatically)
                    # MPython returns all rows in a (F-ordered) cell in data__
                    # Let&#39;s use the cell constructor to return a cellstr.
                    # -&gt; A cellstr is a column vector, not a row vector
                    size = np.asarray(other[&#34;size__&#34;]).tolist()[0]
                    size = size[:-1] + [1]
                    other[&#34;type__&#34;] = &#34;cell&#34;
                    other[&#34;size__&#34;] = np.asarray([size])
                    return Cell._from_runtime(other, _runtime)

                else:
                    raise ValueError(&#34;Don&#39;t know what to do with type&#34;, type__)

            else:
                other = type(other)(
                    zip(other.keys(), map(_from_any, other.values()))
                )
                return Struct.from_any(other)

        if isinstance(other, (list, tuple, set)):
            # nested tuples are cells of cells, not cell arrays
            if _runtime:
                return Cell._from_runtime(other, _runtime)
            else:
                return Cell.from_any(other)

        if isinstance(other, (np.ndarray, int, float, complex, bool)):
            # [array of] numbers -&gt; Array
            if _runtime:
                return Array._from_runtime(other, _runtime)
            else:
                return Array.from_any(other)

        if isinstance(other, str):
            return other

        if isinstance(other, bytes):
            return other.decode()

        if other is None:
            # This can happen when matlab code is called without `nargout`
            return other

        matlab = _import_matlab()
        if matlab and isinstance(other, matlab.object):
            return MatlabFunction._from_runtime(other, _runtime)

        if type(other) in _matlab_array_types():
            return Array._from_runtime(other, _runtime)

        if hasattr(other, &#34;__iter__&#34;):
            # Iterable -&gt; let&#39;s try to make it a cell
            return cls.from_any(list(other), _runtime=_runtime)

        raise TypeError(f&#34;Cannot convert {type(other)} into a matlab object.&#34;)

    @classmethod
    def _from_runtime(cls, obj, _runtime):
        return cls.from_any(obj, _runtime=_runtime)

    @classmethod
    def _to_runtime(cls, obj):
        &#34;&#34;&#34;
        Convert object to representation that the matlab runtime understands.
        &#34;&#34;&#34;
        to_runtime = cls._to_runtime
        from ..utils import sparse  # FIXME: Circular import

        if isinstance(obj, MatlabType):
            # class / structarray / cell
            return obj._as_runtime()

        elif isinstance(obj, (list, tuple, set)):
            return type(obj)(map(to_runtime, obj))

        elif isinstance(obj, dict):
            if &#34;type__&#34; in obj:
                return obj
            return type(obj)(zip(obj.keys(), map(to_runtime, obj.values())))

        elif isinstance(obj, np.ndarray):
            obj = np.asarray(obj)
            if obj.dtype in (object, dict):
                shape, dtype = obj.shape, obj.dtype
                obj = np.fromiter(map(to_runtime, obj.flat), dtype=dtype)
                obj = obj.reshape(shape)
                return obj.tolist()
            return obj

        elif sparse and isinstance(obj, sparse.sparray):
            SparseArray = _imports.SparseArray
            return SparseArray.from_any(obj)._as_runtime()

        else:
            # TODO: do we want to raise if the type is not supported by matlab?
            #
            # Valid types for matlab bindings:
            #   - bool, int, float, complex, str, bytes, bytearray
            #
            # Valid matlab types that we have already dealt with:
            #   - list, tuple, set, dict, ndarray
            #
            # All other values/types are invalid (including `None`!)
            return obj

    def _as_runtime(self):
        raise NotImplementedError

    def _as_matlab_object(self):
        # Backward compatibility
        # FIXME: Or just keep `_as_matlab_object` and remove `_as_runtime`?
        return self._as_runtime()</code></pre>
</details>
<div class="desc"><p>Generic type for objects that have an exact matlab equivalent.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpython.core.base_types.AnyMatlabArray" href="base_types.html#mpython.core.base_types.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="mpython.matlab_class.MatlabClass" href="../matlab_class.html#mpython.matlab_class.MatlabClass">MatlabClass</a></li>
<li><a title="mpython.matlab_function.MatlabFunction" href="../matlab_function.html#mpython.matlab_function.MatlabFunction">MatlabFunction</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mpython.core.MatlabType.from_any"><code class="name flex">
<span>def <span class="ident">from_any</span></span>(<span>other, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert python/matlab objects to <code><a title="mpython.core.MatlabType" href="#mpython.core.MatlabType">MatlabType</a></code> objects
(<code>Cell</code>, <code>Struct</code>, <code>Array</code>, <code>MatlabClass</code>).</p>
<div class="admonition warning">
<p class="admonition-title">Conversion is performed in-place when possible.</p>
</div></div>
</dd>
</dl>
</dd>
<dt id="mpython.core.WrappedArray"><code class="flex name class">
<span>class <span class="ident">WrappedArray</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WrappedArray(np.ndarray, AnyWrappedArray):
    &#34;&#34;&#34;
    Base class for &#34;arrays of things&#34; (`Array`, `Cell`, `Struct`)
    &#34;&#34;&#34;

    # Value used to initalize empty arrays
    @classmethod
    def _DEFAULT(cls, shape: list = ()):
        raise NotImplementedError

    def __str__(self):
        fmt = {&#34;all&#34;: str}  # use str instead of repr for items
        return np.array2string(self, separator=&#34;, &#34;, formatter=fmt)

    def __repr__(self):
        # close to np.array_repr, but hides dtype.
        pre = type(self).__name__ + &#34;(&#34;
        suf = &#34;)&#34;
        arr = np.array2string(self, prefix=pre, suffix=suf, separator=&#34;, &#34;)
        return pre + arr + suf

    def __bool__(self):
        # NumPy arrays do not lower to True/False in a boolean context.
        # We do lower our matlab equivalent using all()
        return np.ndarray.view(np.all(self), np.ndarray).item()

    def __iter__(self):
        # FIXME:
        #   ndarray.__iter__ seems to call __getattr__, which leads
        #   to infinite resizing.
        #   This overload seems to fix it, but may not be computationally
        #   optimal.
        for i in range(len(self)):
            yield self[i]

    def __getitem__(self, index):
        &#34;&#34;&#34;Resize array if needed, then fallback to `np.ndarray` indexing.&#34;&#34;&#34;
        try:
            return super().__getitem__(index)
        except IndexError:
            # We return a delayed version of the current type, with the
            # same shape as the requested view. Its elements will only
            # be inserted into the original object (self) is the view
            # is properly finalized by an eventual call to __setitem__
            # or __setattr__.
            return self._return_delayed(index)

    def __setitem__(self, index, value):
        &#34;&#34;&#34;Resize array if needed, then fallback to `np.ndarray` indexing.&#34;&#34;&#34;
        value = MatlabType.from_any(value)
        try:
            return super().__setitem__(index, value)
        except (IndexError, ValueError):
            self._resize_for_index(index)
            return super().__setitem__(index, value)

    def __delitem__(self, index):
        if isinstance(index, tuple):
            raise TypeError(
                &#34;Multidimensional indices are not supported in `del`.&#34;
            )

        # --- list: delete sequentially, from tail to head -------------
        if hasattr(index, &#34;__iter__&#34;):
            index = (len(self) + i if i &lt; 0 else i for i in index)
            index = sorted(index, reverse=True)
            for i in index:
                del self[i]

        # --- slice: skip the entire slice, if possible ----------------
        elif isinstance(index, slice):
            start, stop, step = index.start, index.stop, index.step

            # --- let&#39;s make the slice parameters a bit more useful ---
            step = step or 1
            # compute true start
            if start is None:
                if step &lt; 0:
                    start = len(self) - 1
                else:
                    start = 0
            if start &lt; 0:
                start = len(self) + start
            # compute stop in terms of &#34;positive indices&#34;
            # (where -1 really means -1, and not n-1)
            if stop is not None:
                if stop &lt; 0:
                    stop = len(self) + stop
            else:
                stop = len(self) if step &gt; 0 else -1
            stop = min(stop, len(self)) if step &gt; 0 else max(stop, -1)
            # align stop with steps
            stop = start + int(np.ceil(abs(stop - start) / abs(step))) * step
            # compute true inclusive stop
            stop_inclusive = stop - step
            # ensure step is positive
            if step &lt; 0:
                start, stop_inclusive, step = stop_inclusive, start, abs(step)

            # --- if non consecutive, fallback to sequential ---
            if step != 1:
                index = range(start, stop + 1, step)
                del self[index]

            # --- otherwise, skip the entire slice ---
            else:
                nb_del = 1 + stop_inclusive - start
                new_shape = list(np.shape(self))
                new_shape[0] -= nb_del
                self[start:-nb_del] = self[stop_inclusive:]
                np.ndarray.resize(self, new_shape, refcheck=False)

        # --- int: skip a single element -------------------------------
        else:
            index = int(index)
            if index &lt; 0:
                index = len(self) + index
            new_shape = list(np.shape(self))
            new_shape[0] -= 1
            self[index:-1] = self[index + 1:]
            np.ndarray.resize(self, new_shape, refcheck=False)

    def _resize_for_index(self, index, set_default=True):
        &#34;&#34;&#34;
        Resize the array so that the (multidimensional) index is not OOB.

        We only support a restricted number of cases:

        * Index should only contain integers and slices
          (no smart indexing, no new axis, no ellipsis)
        * Only integer indices are used to compute the new size.
          This is to be consistent with numpy, where slice-indexing never
          raises `IndexError` (but instead returns the overlap between
          the array and the slice -- eventually empty).

        Other cases could be handled but require much more complicated logic.
        &#34;&#34;&#34;
        input_shape = self.shape
        if not isinstance(index, tuple):
            index = (index,)
        index, new_index = list(index), []
        shape, new_shape = list(np.shape(self)), []
        axis = -1
        while index:
            next_index = index.pop(0)
            if shape:
                next_shape = shape.pop(0)
            else:
                next_shape = 1
            axis += 1
            if isinstance(next_index, int):
                if next_index &lt; 0:
                    next_index = next_shape + next_index
                if next_index &gt;= next_shape:
                    next_shape = next_index + 1
            elif isinstance(next_index, slice):
                # FIXME: this is not exactly right when abs(step) != 1
                step = next_index.step or 1
                start = next_index.start
                stop = next_index.stop
                if start is not None:
                    start = next_shape + start if start &lt; 0 else start
                if stop is not None:
                    stop = next_shape + stop if stop &lt; 0 else stop
                if step &lt; 0:
                    max_index = start
                else:
                    max_index = stop
                if max_index is None:
                    max_index = next_shape
                if max_index &gt; next_shape:
                    next_shape = max_index
            elif not isinstance(next_index, slice):
                raise TypeError(
                    &#34;Can only automatically resize cell if simple &#34;
                    &#34;indexing (int, slice) is used.&#34;
                )
            new_index.append(next_index)
            new_shape.append(next_shape)
        new_shape = new_shape + shape
        if not input_shape:
            # We risk erasing the original scalar whn setting the
            # defaults, so we save it and reinsert it at the end.
            scalar = np.ndarray.view(self, np.ndarray).item()
        np.ndarray.resize(self, new_shape, refcheck=False)
        if set_default:
            arr = np.ndarray.view(self, np.ndarray)
            view_index = tuple(slice(x, None) for x in input_shape)
            view_shape = arr[view_index].shape
            new_data = self._DEFAULT(view_shape)
            arr[view_index] = new_data
            if not input_shape:
                # Insert back scalar in the first position.
                scalar_index = (0,) * arr.ndim
                arr[scalar_index] = scalar

    def _return_delayed(self, index):
        Cell = _imports.Cell
        Struct = _imports.Struct

        if not isinstance(index, tuple):
            index = (index,)

        #   Resize as if we were already performing a valid __setitem__.
        #   This helps us guess the shape of the view.
        #   Also, we&#39;ll hopefully be able to use the allocated space
        #   later if the caller did not mess up their syntax, so there&#39;s
        #   not much wasted performance.
        shape = self.shape
        self._resize_for_index(index, set_default=False)

        #   Ensure that the indexed view is an array, not a single item.
        index_for_view = index
        if ... not in index_for_view:
            index_for_view = index_for_view + (...,)

        sub_shape = np.ndarray.view(self, np.ndarray)[index_for_view].shape

        #   Now, undo resize so that if the caller&#39;s syntax is wrong and
        #   an exception is raised (and caught), it&#39;s as if nothing ever
        #   happened.
        np.ndarray.resize(self, shape, refcheck=False)

        #   If self is wrapped in a DelayedCell/DelayedStruct,
        #   reference wrapper instead of self.
        parent = getattr(self, &#34;_delayed_wrapper&#34;, self)

        if isinstance(self, Cell):
            if sub_shape == ():
                return AnyDelayedArray(parent, index)
            else:
                return DelayedCell(sub_shape, parent, index)

        elif isinstance(self, Struct):
            return DelayedStruct(sub_shape, parent, index)

        else:
            #   In numeric arrays, only seeting OOB items is allowed.
            #   Getting OOB items should raise an error, which this
            #   call to the ndarray accessor will do.
            return super().__getitem__(index)</code></pre>
</details>
<div class="desc"><p>Base class for "arrays of things" (<code>Array</code>, <code>Cell</code>, <code>Struct</code>)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>numpy.ndarray</li>
<li><a title="mpython.core.wrapped_types.AnyWrappedArray" href="wrapped_types.html#mpython.core.wrapped_types.AnyWrappedArray">AnyWrappedArray</a></li>
<li><a title="mpython.core.base_types.AnyMatlabArray" href="base_types.html#mpython.core.base_types.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="mpython.core.base_types.MatlabType" href="base_types.html#mpython.core.base_types.MatlabType">MatlabType</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpython.array.Array" href="../array.html#mpython.array.Array">Array</a></li>
<li><a title="mpython.cell.Cell" href="../cell.html#mpython.cell.Cell">Cell</a></li>
<li><a title="mpython.struct.Struct" href="../struct.html#mpython.struct.Struct">Struct</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mpython.core.wrapped_types.AnyWrappedArray" href="wrapped_types.html#mpython.core.wrapped_types.AnyWrappedArray">AnyWrappedArray</a></b></code>:
<ul class="hlist">
<li><code><a title="mpython.core.wrapped_types.AnyWrappedArray.from_any" href="base_types.html#mpython.core.base_types.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mpython.core.WrappedDelayedArray"><code class="flex name class">
<span>class <span class="ident">WrappedDelayedArray</span></span>
<span>(</span><span>future, parent, *index)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WrappedDelayedArray(AnyDelayedArray):
    &#34;&#34;&#34;
    Base class for future objects with known type.

    See `DelayedStruct`, `DelayedCell`, `DelayedArray`.
    &#34;&#34;&#34;

    def __init__(self, future, parent, *index):
        &#34;&#34;&#34;
        Parameters
        ----------
        future : Struct | Cell | Array
            Concrete object that will be inserted in the parent later.
        parent : Struct | Cell | AnyDelayedArray
            Parent object that contains the future object.
        *index : int | str
            Index of the future obect in its parent.
        &#34;&#34;&#34;
        super().__init__(parent, *index)
        self._future = future

    def __call__(self, *index):
        return self._future.__call__(*index)

    def __getitem__(self, index):
        return self._future.__getitem__(index)

    def __getattr__(self, key):
        return self._future.__getattr__(key)

    def __setitem__(self, index, value):
        self._future.__setitem__(index, value)
        self._finalize()

    def __setattr__(self, key, value):
        if key in type(self)._ATTRIBUTES:
            return super().__setattr__(key, value)
        self._future.__setattr__(key, value)
        self._finalize()</code></pre>
</details>
<div class="desc"><p>Base class for future objects with known type.</p>
<p>See <code><a title="mpython.core.DelayedStruct" href="#mpython.core.DelayedStruct">DelayedStruct</a></code>, <code><a title="mpython.core.DelayedCell" href="#mpython.core.DelayedCell">DelayedCell</a></code>, <code><a title="mpython.core.DelayedArray" href="#mpython.core.DelayedArray">DelayedArray</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>future</code></strong> :&ensp;<code>Struct | Cell | Array</code></dt>
<dd>Concrete object that will be inserted in the parent later.</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>Struct | Cell | AnyDelayedArray</code></dt>
<dd>Parent object that contains the future object.</dd>
<dt><strong><code>*index</code></strong> :&ensp;<code>int | str</code></dt>
<dd>Index of the future obect in its parent.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mpython.core.delayed_types.AnyDelayedArray" href="delayed_types.html#mpython.core.delayed_types.AnyDelayedArray">AnyDelayedArray</a></li>
<li><a title="mpython.core.base_types.AnyMatlabArray" href="base_types.html#mpython.core.base_types.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="mpython.core.base_types.MatlabType" href="base_types.html#mpython.core.base_types.MatlabType">MatlabType</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpython.core.delayed_types.DelayedArray" href="delayed_types.html#mpython.core.delayed_types.DelayedArray">DelayedArray</a></li>
<li><a title="mpython.core.delayed_types.DelayedCell" href="delayed_types.html#mpython.core.delayed_types.DelayedCell">DelayedCell</a></li>
<li><a title="mpython.core.delayed_types.DelayedStruct" href="delayed_types.html#mpython.core.delayed_types.DelayedStruct">DelayedStruct</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mpython.core.delayed_types.AnyDelayedArray" href="delayed_types.html#mpython.core.delayed_types.AnyDelayedArray">AnyDelayedArray</a></b></code>:
<ul class="hlist">
<li><code><a title="mpython.core.delayed_types.AnyDelayedArray.from_any" href="base_types.html#mpython.core.base_types.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mpython.core._DictMixin"><code class="flex name class">
<span>class <span class="ident">_DictMixin</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class _DictMixin(MutableMapping):
    # NOTE:
    #
    #   Making Struct inherit from MutableMapping is a bit hacky
    #   because only scalar Struct implement a proper mapping protocol.
    #   For non-scalar Struct arrays, iteration is over array elements
    #   (not keys), as are `__len__`, `__contains__`, `__eq__`, etc.
    #
    #   The only abstract methods from MutableMapping are:
    #   * __getitem__   -&gt; implemented in Struct
    #   * __setitem__   -&gt; implemented in Struct
    #   * __delitem__   -&gt; implemented in Struct
    #   * __len__       -&gt; !! double meaning, implemented here
    #   * __iter__      -&gt; !! double meaning, implemented here
    #
    #   MutableSequence implements the following non-abstract methods,
    #   but we overload them for speed:
    #   * __contains__  -&gt; !! double meaning
    #   * __eq__        -&gt; !! double meaning -&gt; implemented in np.ndarray
    #   * __ne__        -&gt; !! double meaning -&gt; implemented in np.ndarray
    #   * keys          -&gt; implemented here
    #   * items         -&gt; implemented here
    #   * values        -&gt; implemented here
    #   * get           -&gt; implemented in Struct
    #   * pop           -&gt; implemented in Struct
    #   * popitem       -&gt; implemented in Struct
    #   * clear         -&gt; implemented in Struct
    #   * update        -&gt; implemented in Struct
    #   * setdefault    -&gt; implemented in Struct

    # --- views --------------------------------------------------------
    class KeysView(KeysView):
        def __init__(self, parent):
            self._parent = parent

        def __len__(self):
            return len(self._parent._allkeys())

        def __iter__(self):
            return iter(self._parent._allkeys())

        def __contains__(self, key):
            return key in self._parent._allkeys()

        def __repr__(self):
            return f&#34;dict_keys({list(self)})&#34;

        __str__ = __repr__

    class ValuesView(ValuesView):
        def __init__(self, parent):
            self._parent = parent

        def __len__(self):
            return len(self._parent.as_dict().values())

        def __iter__(self):
            return iter(self._parent.as_dict().values())

        def __contains__(self, value):
            return value in self._parent.as_dict().values()

        def __repr__(self):
            return f&#34;dict_values({list(self)})&#34;

        __str__ = __repr__

    class ItemsView(ItemsView):
        def __init__(self, parent):
            self._parent = parent

        def __len__(self):
            return len(self._parent.as_dict().items())

        def __iter__(self):
            return iter(self._parent.as_dict().items())

        def __contains__(self, item):
            return item in self._parent.as_dict().items()

        def __repr__(self):
            return f&#34;dict_items({list(self)})&#34;

        __str__ = __repr__

    # --- magic --------------------------------------------------------

    def __len__(self):
        if self.ndim:
            return np.ndarray.__len__(self)
        else:
            return len(self.keys())

    def __contains__(self, key):
        if self.ndim:
            return np.ndarray.__contains__(self, key)
        else:
            return key in self.keys()

    def __iter__(self):
        if self.ndim:
            return np.ndarray.__iter__(self)
        else:
            return iter(self.keys())

    def __getitem__(self, key):
        if key in self.keys():
            # NOTE
            #   If some of the dictionaries in the array do not have
            #   their field `key` properly set, we assign an empty
            #   numeric array (same default value as in matlab).

            arr = np.ndarray.view(self, np.ndarray)
            opt = dict(flags=[&#34;refs_ok&#34;, &#34;zerosize_ok&#34;], op_flags=[&#34;readonly&#34;])
            with np.nditer(arr, **opt) as iter:
                for elem in iter:
                    elem.item().setdefault(key, _empty_array())

            # NOTE
            #   We then defer to `as_dict`

            return self.as_dict(keys=[key])[key]

        else:
            # NOTE
            #   We return a new (delayed) struct, whose elements under
            #  `key` are delayed arrays that point to `self` (and *not*
            #   to the delayed struct). This way, when the objects
            #   implicitely assigned to `key` get finalized, they are
            #   inserted into the orginal struct (`self`), not into
            #   the delayed struct (`delayed`).
            #
            #   We do not need to use a `DelayedStruct` here.
            parent = getattr(self, &#34;_delayed_wrapper&#34;, self)

            Struct = _imports.Struct

            delayed = Struct(self.shape)
            opt = dict(
                flags=[&#34;refs_ok&#34;, &#34;zerosize_ok&#34;, &#34;multi_index&#34;],
                op_flags=[&#34;writeonly&#34;, &#34;no_broadcast&#34;],
            )
            arr = np.ndarray.view(delayed, np.ndarray)
            with np.nditer(arr, **opt) as iter:
                for elem in iter:
                    item = elem.item()
                    item[key] = AnyDelayedArray(parent, iter.multi_index, key)

            return delayed.as_dict(keys=[key])[key]

    def __setitem__(self, key, value):
        arr = np.ndarray.view(self, np.ndarray)

        if np.ndim(arr) == 0:
            # Scalar array: assign value to the field
            if isinstance(value, self.deal):
                # `deal` objects are cells and cannot be 0-dim
                raise ValueError(&#34;Cannot broadcast.&#34;)
            arr.item()[key] = MatlabType.from_any(value)

        elif isinstance(value, self.deal):
            # Each element in the struct array is matched with an element
            # in the &#34;deal&#34; array.
            value = value.broadcast_to_struct(self)
            opt = dict(
                flags=[&#34;refs_ok&#34;, &#34;zerosize_ok&#34;, &#34;multi_index&#34;],
                op_flags=[&#34;readonly&#34;]
            )
            with np.nditer(arr, **opt) as iter:
                for elem in iter:
                    val = value[iter.multi_index]
                    if isinstance(val, self.deal):
                        val = val.to_cell()
                    elem.item()[key] = MatlabType.from_any(val)

        else:
            # Assign the same value to all elements in the struct array.
            opt = dict(flags=[&#34;refs_ok&#34;, &#34;zerosize_ok&#34;], op_flags=[&#34;readonly&#34;])
            value = MatlabType.from_any(value)
            with np.nditer(arr, **opt) as iter:
                for elem in iter:
                    elem.item()[key] = value

    def __delitem__(self, key):
        if key not in self._allkeys():
            raise KeyError(key)
        arr = np.ndarray.view(self, np.ndarray)
        opt = dict(flags=[&#34;refs_ok&#34;, &#34;zerosize_ok&#34;], op_flags=[&#34;readonly&#34;])
        with np.nditer(arr, **opt) as iter:
            for elem in iter:
                del elem.item()[key]

    # --- mapping ------------------------------------------------------

    def keys(self):
        return self.KeysView(self)

    def items(self):
        return self.ItemsView(self)

    def values(self):
        return self.ValuesView(self)

    def setdefault(self, key, value=None):
        arr = np.ndarray.view(self, np.ndarray)
        opt = dict(flags=[&#34;refs_ok&#34;, &#34;zerosize_ok&#34;], op_flags=[&#34;readonly&#34;])
        with np.nditer(arr, **opt) as iter:
            for elem in iter:
                item = elem.item()
                if value is None:
                    value = _empty_array()
                else:
                    value = MatlabType.from_any(value)
                item.setdefault(key, value)

    def update(self, other):
        Struct = _imports.Struct

        other = Struct.from_any(other)
        other = np.ndarray.view(other, np.ndarray)
        other = np.broadcast_to(other, self.shape)

        arr = np.ndarray.view(self, np.ndarray)
        opt = dict(
            flags=[&#34;refs_ok&#34;, &#34;zerosize_ok&#34;, &#34;multi_index&#34;],
            op_flags=[&#34;readonly&#34;]
        )
        with np.nditer(arr, **opt) as iter:
            for elem in iter:
                other_elem = other[iter.multi_index]
                item = elem.item()
                item.update(other_elem)

    # --- helper ------------------------------------------------------
    class deal:  # FIXME: Removed dependency to Cell
        &#34;&#34;&#34;
        Helper class to assign values into a specific field of a Struct array.

        ```python
        s = Struct(2)
        s.field = [1, 2]
        print(s)
        # [{&#34;field&#34;: [1, 2]}, {&#34;field&#34;: [1, 2]}]

        s = Struct(2)
        s.field = Struct.deal([1, 2])
        print(s)
        # [{&#34;field&#34;: 1}, {&#34;field&#34;: 2}]
        ```
        &#34;&#34;&#34;

        # The idea is to have a type that tells Struct.__setattr__
        # that we want to broadcast the object before assigning it to
        # the field. We let the target struct tell this object which
        # field is being assigned and this object transforms itself
        # into a struct array with a single field (but multiple elements).
        # We can then let broadcasting do its magic.

        def __new__(cls, arg, **kwargs):
            return cls.from_any(arg, **kwargs)

        def broadcast_to_struct(self, struct):
            shape = struct.shape + self.shape[len(struct.shape):]
            return np.broadcast_to(self, shape)

        def to_cell(self):
            Cell = _imports.Cell
            return np.ndarray.view(self, Cell)</code></pre>
</details>
<div class="desc"><p>A MutableMapping is a generic container for associating
key/value pairs.</p>
<p>This class provides concrete generic implementations of all
methods except for <strong>getitem</strong>, <strong>setitem</strong>, <strong>delitem</strong>,
<strong>iter</strong>, and <strong>len</strong>.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpython.struct.Struct" href="../struct.html#mpython.struct.Struct">Struct</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mpython.core._DictMixin.ItemsView"><code class="name">var <span class="ident">ItemsView</span></code></dt>
<dd>
<div class="desc"><p>A set is a finite, iterable container.</p>
<p>This class provides concrete generic implementations of all
methods except for <strong>contains</strong>, <strong>iter</strong> and <strong>len</strong>.</p>
<p>To override the comparisons (presumably for speed, as the
semantics are fixed), redefine <strong>le</strong> and <strong>ge</strong>,
then the other operations will automatically follow suit.</p></div>
</dd>
<dt id="mpython.core._DictMixin.KeysView"><code class="name">var <span class="ident">KeysView</span></code></dt>
<dd>
<div class="desc"><p>A set is a finite, iterable container.</p>
<p>This class provides concrete generic implementations of all
methods except for <strong>contains</strong>, <strong>iter</strong> and <strong>len</strong>.</p>
<p>To override the comparisons (presumably for speed, as the
semantics are fixed), redefine <strong>le</strong> and <strong>ge</strong>,
then the other operations will automatically follow suit.</p></div>
</dd>
<dt id="mpython.core._DictMixin.ValuesView"><code class="name">var <span class="ident">ValuesView</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="mpython.core._DictMixin.deal"><code class="name">var <span class="ident">deal</span></code></dt>
<dd>
<div class="desc"><p>Helper class to assign values into a specific field of a Struct array.</p>
<pre><code class="language-python">s = Struct(2)
s.field = [1, 2]
print(s)
# [{&quot;field&quot;: [1, 2]}, {&quot;field&quot;: [1, 2]}]

s = Struct(2)
s.field = Struct.deal([1, 2])
print(s)
# [{&quot;field&quot;: 1}, {&quot;field&quot;: 2}]
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mpython.core._DictMixin.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    return self.ItemsView(self)</code></pre>
</details>
<div class="desc"><p>D.items() -&gt; a set-like object providing a view on D's items</p></div>
</dd>
<dt id="mpython.core._DictMixin.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    return self.KeysView(self)</code></pre>
</details>
<div class="desc"><p>D.keys() -&gt; a set-like object providing a view on D's keys</p></div>
</dd>
<dt id="mpython.core._DictMixin.setdefault"><code class="name flex">
<span>def <span class="ident">setdefault</span></span>(<span>self, key, value=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setdefault(self, key, value=None):
    arr = np.ndarray.view(self, np.ndarray)
    opt = dict(flags=[&#34;refs_ok&#34;, &#34;zerosize_ok&#34;], op_flags=[&#34;readonly&#34;])
    with np.nditer(arr, **opt) as iter:
        for elem in iter:
            item = elem.item()
            if value is None:
                value = _empty_array()
            else:
                value = MatlabType.from_any(value)
            item.setdefault(key, value)</code></pre>
</details>
<div class="desc"><p>D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</p></div>
</dd>
<dt id="mpython.core._DictMixin.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, other):
    Struct = _imports.Struct

    other = Struct.from_any(other)
    other = np.ndarray.view(other, np.ndarray)
    other = np.broadcast_to(other, self.shape)

    arr = np.ndarray.view(self, np.ndarray)
    opt = dict(
        flags=[&#34;refs_ok&#34;, &#34;zerosize_ok&#34;, &#34;multi_index&#34;],
        op_flags=[&#34;readonly&#34;]
    )
    with np.nditer(arr, **opt) as iter:
        for elem in iter:
            other_elem = other[iter.multi_index]
            item = elem.item()
            item.update(other_elem)</code></pre>
</details>
<div class="desc"><p>D.update([E, ]**F) -&gt; None.
Update D from mapping/iterable E and F.
If E present and has a .keys() method, does:
for k in E.keys(): D[k] = E[k]
If E present and lacks .keys() method, does:
for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v</p></div>
</dd>
<dt id="mpython.core._DictMixin.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    return self.ValuesView(self)</code></pre>
</details>
<div class="desc"><p>D.values() -&gt; an object providing a view on D's values</p></div>
</dd>
</dl>
</dd>
<dt id="mpython.core._ListMixin"><code class="flex name class">
<span>class <span class="ident">_ListMixin</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class _ListMixin(_ListishMixin, MutableSequence):
    &#34;&#34;&#34;These methods are implemented in Cell, but not in Array or Struct.&#34;&#34;&#34;

    # NOTE:
    #   The only abstract methods from MutableSequence are:
    #   * __getitem__   -&gt; inherited from WrappedArray
    #   * __setitem__   -&gt; inherited from WrappedArray
    #   * __delitem__   -&gt; implemented here
    #   * __len__       -&gt; inherited from np.ndarray
    #   * insert        -&gt; implemented here
    #
    #   MutableSequence implements the following non-abstract methods,
    #   but we overload them for speed:
    #   * index         -&gt; implemented here
    #   * count         -&gt; implemented here
    #   * append        -&gt; inherited from _ListishMixin
    #   * clear         -&gt; inherited from _ListishMixin
    #   * reverse       -&gt; implemented here
    #   * extend        -&gt; inherited from _ListishMixin
    #   * pop           -&gt; implemented here
    #   * remove        -&gt; implemented here
    #   * __iter__      -&gt; inherited from np.ndarray
    #   * __reversed__  -&gt; inherited from Sequence
    #   * __iadd__      -&gt; implemented here
    #   * __eq__        -&gt; implemented here
    #   * __ne__        -&gt; implemented here
    #   * __ge__        -&gt; implemented here
    #   * __gt__        -&gt; implemented here
    #   * __le__        -&gt; implemented here
    #   * __lt__        -&gt; implemented here
    #
    #   Mutable implements the following non-abstract method, whose
    #   behaviour differs from that of np.ndarray.
    #   We use np.ndarray&#39;s instead.
    #   * __contains__  -&gt; inherited from np.ndarray

    # --- ndarray ------------------------------------------------------

    # need to explicitely reference np.ndarray methods otherwise it
    # goes back to MutableSequence, which raises.
    __len__ = WrappedArray.__len__
    __getitem__ = WrappedArray.__getitem__
    __setitem__ = WrappedArray.__setitem__
    __delitem__ = WrappedArray.__delitem__
    __contains__ = WrappedArray.__contains__
    __iter__ = WrappedArray.__iter__

    # --- magic --------------------------------------------------------

    def __add__(self, other):
        other = type(self).from_any(other)
        return np.concatenate([self, other])

    def __radd__(self, other):
        other = type(self).from_any(other)
        return np.concatenate([other, self])

    def __iadd__(self, other):
        self.extend(other)
        return self

    def __mul__(self, value):
        return np.concatenate([self] * value)

    def __rmul__(self, value):
        return np.concatenate([self] * value)

    def __imul__(self, value):
        length = len(self)
        new_shape = list(np.shape(self))
        new_shape[0] *= value
        np.ndarray.resize(self, new_shape, refcheck=False)
        for i in range(1, value):
            self[i * length:(i + 1) * length] = self[:length]
        return self

    # In lists, __contains__ should be treated as meaning &#34;contains this
    # element along the first dimension.&#34; I.e.,
    # `value in sequence` should be equivalent to `value in iter(sequence)`.
    #
    # In contrast, ndarray&#39;s __contains__ is used &#34;element-wise&#34;.
    # I.e., it is equivalent to `value in sequence.flat`.
    # It is the main reason ndarray do not implement the MutableSequence
    # protocol:
    # https://github.com/numpy/numpy/issues/2776#issuecomment-652584346
    #
    # We use the numpy behaviour, and implement list_contains to recover
    # the list behaviour.

    def list_contains(self, value, broadcast=True):
        &#34;&#34;&#34;
        Check whether a value is in the object, when iterated along its
        first dimension.

        Should be roughly equivalent to `value in iter(self)`, although
        it also takes care of collapsing boolean arrays into a single
        boolean by calling `all()` on them.

        * If `broadcast=True` (default), equality is loose in the sense
          that `1` matches `[1, 1, 1]`.
        * If `broadcast=False`, array-like objects only match if they
          have the exact same shape.
        &#34;&#34;&#34;
        value = np.asarray(value)
        for elem in self:
            elem = np.asarray(elem)
            if not broadcast and value.shape != elem.shape:
                continue
            if (elem == value).all():
                return True
        return False

    # --- sequence -----------------------------------------------------

    def count(self, value, broadcast=True):
        &#34;&#34;&#34;
        Return number of occurrences of value, when iterating along the
        object&#39;s first dimension.

        * If `broadcast=True` (default), equality is loose in the sense
          that `1` matches `[1, 1, 1]`.
        * If `broadcast=False`, array-like objects only match if they
          have the exact same shape.
        &#34;&#34;&#34;
        value = np.asarray(value)

        def iter():
            for elem in self:
                elem = np.asarray(elem)
                if not broadcast and value.shape != elem.shape:
                    yield False
                yield bool((elem == value).all())

        return sum(iter())

    def index(self, value, broadcast=True):
        &#34;&#34;&#34;
        Return first index of value, when iterating along the object&#39;s
        first dimension.

        * If `broadcast=True` (default), equality is loose in the sense
          that `1` matches `[1, 1, 1]`.
        * If `broadcast=False`, array-like objects only match if they
          have the exact same shape.
        &#34;&#34;&#34;
        value = np.asarray(value)
        for i, elem in enumerate(self):
            elem = np.asarray(elem)
            if not broadcast and value.shape != elem.shape:
                continue
            if (elem == value).all():
                return i
        raise ValueError(value, &#34;is not in&#34;, type(self).__name__)

    def insert(self, index, obj):
        &#34;&#34;&#34;Insert object before index.&#34;&#34;&#34;
        if index &lt; 0:
            # +1 because we insert *after* the index if negative
            index = len(self) + index + 1
        if not isinstance(index, int):
            raise TypeError(&#34;Only scalar elements can be inserted.&#34;)
        new_shape = list(np.shape(self))
        new_shape[0] += 1
        np.ndarray.resize(self, new_shape, refcheck=False)
        self[index + 1:] = self[index:-1]
        self[index] = obj

    def pop(self, index=-1):
        &#34;&#34;&#34;Remove and return item at index (default last).&#34;&#34;&#34;
        if index &lt; 0:
            index = len(self) + index
        # need to copy as its memory location will be overwritten by del
        if not isinstance(index, int):
            raise TypeError(&#34;Only scalar indices can be popped.&#34;)
        value = np.copy(self[index])
        del self[index]
        return value

    def remove(self, value):
        &#34;&#34;&#34;Remove first occurrence of value.&#34;&#34;&#34;
        new_shape = list(np.shape(self))
        new_shape[0] -= 1
        index = self.index(value)
        del self[index]

    def reverse(self):
        &#34;&#34;&#34;Reverse *IN PLACE*.&#34;&#34;&#34;
        self[:] = self[::-1]

    def sort(self, *, key=None, reverse=False, kind=&#34;stable&#34;, axis=0):
        &#34;&#34;&#34;
        Sort the list in ascending order and return None.

        The sort is in-place (i.e. the list itself is modified) and stable
        (i.e. the order of two equal elements is maintained).

        If a key function is given, apply it once to each list item and sort
        them, ascending or descending, according to their function values.

        The reverse flag can be set to sort in descending order.

        !!! note
            We further expose options from `np.ndarray.sort`, which is used
            under the hood. However, we use different defaults
            (kind=&#34;stable&#34; instead of &#34;quicksort&#34;, axis=0 instead of -1).

            If `key` is provided, we fallback to `list.sort`
            (triggers a temporary copy).
        &#34;&#34;&#34;
        if key:
            aslist = list(np.moveaxis(self, axis, 0))
            aslist.sort(key=key, reverse=reverse)
            asarray = np.stack(aslist, axis=axis)
            self[...] = asarray
        else:
            np.ndarray.sort(self, kind=kind, axis=axis)
            if reverse:
                self.reverse()</code></pre>
</details>
<div class="desc"><p>These methods are implemented in Cell, but not in Array or Struct.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mpython.core.mixin_types._ListishMixin</li>
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpython.cell.Cell" href="../cell.html#mpython.cell.Cell">Cell</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mpython.core._ListMixin.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>self, value, broadcast=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count(self, value, broadcast=True):
    &#34;&#34;&#34;
    Return number of occurrences of value, when iterating along the
    object&#39;s first dimension.

    * If `broadcast=True` (default), equality is loose in the sense
      that `1` matches `[1, 1, 1]`.
    * If `broadcast=False`, array-like objects only match if they
      have the exact same shape.
    &#34;&#34;&#34;
    value = np.asarray(value)

    def iter():
        for elem in self:
            elem = np.asarray(elem)
            if not broadcast and value.shape != elem.shape:
                yield False
            yield bool((elem == value).all())

    return sum(iter())</code></pre>
</details>
<div class="desc"><p>Return number of occurrences of value, when iterating along the
object's first dimension.</p>
<ul>
<li>If <code>broadcast=True</code> (default), equality is loose in the sense
that <code>1</code> matches <code>[1, 1, 1]</code>.</li>
<li>If <code>broadcast=False</code>, array-like objects only match if they
have the exact same shape.</li>
</ul></div>
</dd>
<dt id="mpython.core._ListMixin.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>self, value, broadcast=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index(self, value, broadcast=True):
    &#34;&#34;&#34;
    Return first index of value, when iterating along the object&#39;s
    first dimension.

    * If `broadcast=True` (default), equality is loose in the sense
      that `1` matches `[1, 1, 1]`.
    * If `broadcast=False`, array-like objects only match if they
      have the exact same shape.
    &#34;&#34;&#34;
    value = np.asarray(value)
    for i, elem in enumerate(self):
        elem = np.asarray(elem)
        if not broadcast and value.shape != elem.shape:
            continue
        if (elem == value).all():
            return i
    raise ValueError(value, &#34;is not in&#34;, type(self).__name__)</code></pre>
</details>
<div class="desc"><p>Return first index of value, when iterating along the object's
first dimension.</p>
<ul>
<li>If <code>broadcast=True</code> (default), equality is loose in the sense
that <code>1</code> matches <code>[1, 1, 1]</code>.</li>
<li>If <code>broadcast=False</code>, array-like objects only match if they
have the exact same shape.</li>
</ul></div>
</dd>
<dt id="mpython.core._ListMixin.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, index, obj)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, index, obj):
    &#34;&#34;&#34;Insert object before index.&#34;&#34;&#34;
    if index &lt; 0:
        # +1 because we insert *after* the index if negative
        index = len(self) + index + 1
    if not isinstance(index, int):
        raise TypeError(&#34;Only scalar elements can be inserted.&#34;)
    new_shape = list(np.shape(self))
    new_shape[0] += 1
    np.ndarray.resize(self, new_shape, refcheck=False)
    self[index + 1:] = self[index:-1]
    self[index] = obj</code></pre>
</details>
<div class="desc"><p>Insert object before index.</p></div>
</dd>
<dt id="mpython.core._ListMixin.list_contains"><code class="name flex">
<span>def <span class="ident">list_contains</span></span>(<span>self, value, broadcast=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_contains(self, value, broadcast=True):
    &#34;&#34;&#34;
    Check whether a value is in the object, when iterated along its
    first dimension.

    Should be roughly equivalent to `value in iter(self)`, although
    it also takes care of collapsing boolean arrays into a single
    boolean by calling `all()` on them.

    * If `broadcast=True` (default), equality is loose in the sense
      that `1` matches `[1, 1, 1]`.
    * If `broadcast=False`, array-like objects only match if they
      have the exact same shape.
    &#34;&#34;&#34;
    value = np.asarray(value)
    for elem in self:
        elem = np.asarray(elem)
        if not broadcast and value.shape != elem.shape:
            continue
        if (elem == value).all():
            return True
    return False</code></pre>
</details>
<div class="desc"><p>Check whether a value is in the object, when iterated along its
first dimension.</p>
<p>Should be roughly equivalent to <code>value in iter(self)</code>, although
it also takes care of collapsing boolean arrays into a single
boolean by calling <code>all()</code> on them.</p>
<ul>
<li>If <code>broadcast=True</code> (default), equality is loose in the sense
that <code>1</code> matches <code>[1, 1, 1]</code>.</li>
<li>If <code>broadcast=False</code>, array-like objects only match if they
have the exact same shape.</li>
</ul></div>
</dd>
<dt id="mpython.core._ListMixin.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, index=-1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, index=-1):
    &#34;&#34;&#34;Remove and return item at index (default last).&#34;&#34;&#34;
    if index &lt; 0:
        index = len(self) + index
    # need to copy as its memory location will be overwritten by del
    if not isinstance(index, int):
        raise TypeError(&#34;Only scalar indices can be popped.&#34;)
    value = np.copy(self[index])
    del self[index]
    return value</code></pre>
</details>
<div class="desc"><p>Remove and return item at index (default last).</p></div>
</dd>
<dt id="mpython.core._ListMixin.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, value):
    &#34;&#34;&#34;Remove first occurrence of value.&#34;&#34;&#34;
    new_shape = list(np.shape(self))
    new_shape[0] -= 1
    index = self.index(value)
    del self[index]</code></pre>
</details>
<div class="desc"><p>Remove first occurrence of value.</p></div>
</dd>
<dt id="mpython.core._ListMixin.reverse"><code class="name flex">
<span>def <span class="ident">reverse</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse(self):
    &#34;&#34;&#34;Reverse *IN PLACE*.&#34;&#34;&#34;
    self[:] = self[::-1]</code></pre>
</details>
<div class="desc"><p>Reverse <em>IN PLACE</em>.</p></div>
</dd>
<dt id="mpython.core._ListMixin.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, *, key=None, reverse=False, kind='stable', axis=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, *, key=None, reverse=False, kind=&#34;stable&#34;, axis=0):
    &#34;&#34;&#34;
    Sort the list in ascending order and return None.

    The sort is in-place (i.e. the list itself is modified) and stable
    (i.e. the order of two equal elements is maintained).

    If a key function is given, apply it once to each list item and sort
    them, ascending or descending, according to their function values.

    The reverse flag can be set to sort in descending order.

    !!! note
        We further expose options from `np.ndarray.sort`, which is used
        under the hood. However, we use different defaults
        (kind=&#34;stable&#34; instead of &#34;quicksort&#34;, axis=0 instead of -1).

        If `key` is provided, we fallback to `list.sort`
        (triggers a temporary copy).
    &#34;&#34;&#34;
    if key:
        aslist = list(np.moveaxis(self, axis, 0))
        aslist.sort(key=key, reverse=reverse)
        asarray = np.stack(aslist, axis=axis)
        self[...] = asarray
    else:
        np.ndarray.sort(self, kind=kind, axis=axis)
        if reverse:
            self.reverse()</code></pre>
</details>
<div class="desc"><p>Sort the list in ascending order and return None.</p>
<p>The sort is in-place (i.e. the list itself is modified) and stable
(i.e. the order of two equal elements is maintained).</p>
<p>If a key function is given, apply it once to each list item and sort
them, ascending or descending, according to their function values.</p>
<p>The reverse flag can be set to sort in descending order.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We further expose options from <code>np.ndarray.sort</code>, which is used
under the hood. However, we use different defaults
(kind="stable" instead of "quicksort", axis=0 instead of -1).</p>
<p>If <code>key</code> is provided, we fallback to <code>list.sort</code>
(triggers a temporary copy).</p>
</div></div>
</dd>
</dl>
</dd>
<dt id="mpython.core._ListishMixin"><code class="flex name class">
<span>class <span class="ident">_ListishMixin</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class _ListishMixin:
    &#34;&#34;&#34;These methods are implemented in Cell and Array, but not Struct.&#34;&#34;&#34;

    # TODO:
    #   The following _ListLike methods could potentially be moved here
    #   (i.e., be implemented in Array as well as Cell):
    #
    #   * index
    #   * count
    #   * reverse
    #   * pop
    #   * remove

    def append(self, value):
        &#34;&#34;&#34;
        Append object to the end of the list
        (along the first dimension).
        &#34;&#34;&#34;
        new_shape = list(np.shape(self))
        new_shape[0] += 1
        np.ndarray.resize(self, new_shape, refcheck=False)
        self[-1] = value

    def extend(self, value):
        &#34;&#34;&#34;
        Extend list by appending elements from the iterable
        (along the first dimension).
        &#34;&#34;&#34;
        value = type(self).from_any(value)
        init_len = len(self)
        batch = len(self) + len(value)
        shape = np.broadcast_shapes(np.shape(self)[1:], np.shape(value)[1:])
        new_shape = [batch] + list(shape)
        np.ndarray.resize(self, new_shape, refcheck=False)
        self[init_len:] = value

    def clear(self):
        &#34;&#34;&#34;Remove all items by setting the first axis to have size 0.&#34;&#34;&#34;
        zero_shape = list(np.shape(self))
        zero_shape[0] = 0
        np.ndarray.resize(zero_shape, refcheck=False)</code></pre>
</details>
<div class="desc"><p>These methods are implemented in Cell and Array, but not Struct.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpython.array.Array" href="../array.html#mpython.array.Array">Array</a></li>
<li>mpython.core.mixin_types._ListMixin</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mpython.core._ListishMixin.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, value):
    &#34;&#34;&#34;
    Append object to the end of the list
    (along the first dimension).
    &#34;&#34;&#34;
    new_shape = list(np.shape(self))
    new_shape[0] += 1
    np.ndarray.resize(self, new_shape, refcheck=False)
    self[-1] = value</code></pre>
</details>
<div class="desc"><p>Append object to the end of the list
(along the first dimension).</p></div>
</dd>
<dt id="mpython.core._ListishMixin.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Remove all items by setting the first axis to have size 0.&#34;&#34;&#34;
    zero_shape = list(np.shape(self))
    zero_shape[0] = 0
    np.ndarray.resize(zero_shape, refcheck=False)</code></pre>
</details>
<div class="desc"><p>Remove all items by setting the first axis to have size 0.</p></div>
</dd>
<dt id="mpython.core._ListishMixin.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, value):
    &#34;&#34;&#34;
    Extend list by appending elements from the iterable
    (along the first dimension).
    &#34;&#34;&#34;
    value = type(self).from_any(value)
    init_len = len(self)
    batch = len(self) + len(value)
    shape = np.broadcast_shapes(np.shape(self)[1:], np.shape(value)[1:])
    new_shape = [batch] + list(shape)
    np.ndarray.resize(self, new_shape, refcheck=False)
    self[init_len:] = value</code></pre>
</details>
<div class="desc"><p>Extend list by appending elements from the iterable
(along the first dimension).</p></div>
</dd>
</dl>
</dd>
<dt id="mpython.core._SparseMixin"><code class="flex name class">
<span>class <span class="ident">_SparseMixin</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class _SparseMixin:
    &#34;&#34;&#34;Methods common to the scipy.sparse and dense backends.&#34;&#34;&#34;

    def _as_runtime(self) -&gt; dict:
        # NOTE: self[self.nonzero()] sometimes return a sparse array
        #       (when self is entirely zeros?). We must therefore
        #       explictly convert `values` to a (dense) numpy array.
        indices = self.nonzero()
        values = self[indices].reshape([-1, 1]).astype(np.double)
        if hasattr(values, &#39;todense&#39;):
            values = values.todense()
        indices = np.stack(indices, -1)
        indices += 1
        size = np.array([[*np.shape(self)]])
        return dict(
            type__=&#34;sparse&#34;,
            size__=size,
            indices__=indices,
            values__=values,
        )

    @classmethod
    def _from_runtime(cls, dictobj: dict, runtime=None):
        # NOTE: If there is a single nonzero value, it is passed as a
        # scalar float, rather than a matlab.double.
        if dictobj[&#34;type__&#34;] != &#34;sparse&#34;:
            raise ValueError(&#34;Not a matlab sparse matrix&#34;)
        size = np.array(dictobj[&#34;size__&#34;], dtype=np.uint64).ravel()
        size = size.tolist()
        ndim = len(size)
        if isinstance(dictobj[&#34;values__&#34;], float):
            dtype = np.double
        else:
            dtype = _matlab_array_types()[type(dictobj[&#34;values__&#34;])]
        indices = np.asarray(dictobj[&#34;indices__&#34;], dtype=np.long)
        values = np.asarray(dictobj[&#34;values__&#34;], dtype=dtype).ravel()
        indices -= 1
        if indices.size == 0:
            indices = indices.reshape([0, ndim])
        elif indices.shape[0] == 1:
            # NOTE: I&#39;ve encountered this issue while runngin the PEB
            # tutorial, but it is difficult to find a minimal example.
            # It seems that for some reason, find() has returned row vectors
            # instead of column vectors, so [ii, jj] generates a long row
            # vector. When this is detected, I properly unfold the data,
            # but this should probably be fixed in mpython_endpoint
            # as well.
            indices = indices.reshape([ndim, -1]).T
        return cls.from_coo(values, indices.T, size)</code></pre>
</details>
<div class="desc"><p>Methods common to the scipy.sparse and dense backends.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpython.sparse_array.SparseArray" href="../sparse_array.html#mpython.sparse_array.SparseArray">SparseArray</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mpython" href="../index.html">mpython</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="mpython.core.base_types" href="base_types.html">mpython.core.base_types</a></code></li>
<li><code><a title="mpython.core.delayed_types" href="delayed_types.html">mpython.core.delayed_types</a></code></li>
<li><code><a title="mpython.core.mixin_types" href="mixin_types.html">mpython.core.mixin_types</a></code></li>
<li><code><a title="mpython.core.wrapped_types" href="wrapped_types.html">mpython.core.wrapped_types</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mpython.core.AnyDelayedArray" href="#mpython.core.AnyDelayedArray">AnyDelayedArray</a></code></h4>
<ul class="">
<li><code><a title="mpython.core.AnyDelayedArray.as_cell" href="#mpython.core.AnyDelayedArray.as_cell">as_cell</a></code></li>
<li><code><a title="mpython.core.AnyDelayedArray.as_num" href="#mpython.core.AnyDelayedArray.as_num">as_num</a></code></li>
<li><code><a title="mpython.core.AnyDelayedArray.as_obj" href="#mpython.core.AnyDelayedArray.as_obj">as_obj</a></code></li>
<li><code><a title="mpython.core.AnyDelayedArray.as_struct" href="#mpython.core.AnyDelayedArray.as_struct">as_struct</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpython.core.AnyMatlabArray" href="#mpython.core.AnyMatlabArray">AnyMatlabArray</a></code></h4>
<ul class="">
<li><code><a title="mpython.core.AnyMatlabArray.as_cell" href="#mpython.core.AnyMatlabArray.as_cell">as_cell</a></code></li>
<li><code><a title="mpython.core.AnyMatlabArray.as_num" href="#mpython.core.AnyMatlabArray.as_num">as_num</a></code></li>
<li><code><a title="mpython.core.AnyMatlabArray.as_struct" href="#mpython.core.AnyMatlabArray.as_struct">as_struct</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpython.core.AnyWrappedArray" href="#mpython.core.AnyWrappedArray">AnyWrappedArray</a></code></h4>
</li>
<li>
<h4><code><a title="mpython.core.DelayedArray" href="#mpython.core.DelayedArray">DelayedArray</a></code></h4>
</li>
<li>
<h4><code><a title="mpython.core.DelayedCell" href="#mpython.core.DelayedCell">DelayedCell</a></code></h4>
</li>
<li>
<h4><code><a title="mpython.core.DelayedStruct" href="#mpython.core.DelayedStruct">DelayedStruct</a></code></h4>
</li>
<li>
<h4><code><a title="mpython.core.MatlabType" href="#mpython.core.MatlabType">MatlabType</a></code></h4>
<ul class="">
<li><code><a title="mpython.core.MatlabType.from_any" href="#mpython.core.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpython.core.WrappedArray" href="#mpython.core.WrappedArray">WrappedArray</a></code></h4>
</li>
<li>
<h4><code><a title="mpython.core.WrappedDelayedArray" href="#mpython.core.WrappedDelayedArray">WrappedDelayedArray</a></code></h4>
</li>
<li>
<h4><code><a title="mpython.core._DictMixin" href="#mpython.core._DictMixin">_DictMixin</a></code></h4>
<ul class="two-column">
<li><code><a title="mpython.core._DictMixin.ItemsView" href="#mpython.core._DictMixin.ItemsView">ItemsView</a></code></li>
<li><code><a title="mpython.core._DictMixin.KeysView" href="#mpython.core._DictMixin.KeysView">KeysView</a></code></li>
<li><code><a title="mpython.core._DictMixin.ValuesView" href="#mpython.core._DictMixin.ValuesView">ValuesView</a></code></li>
<li><code><a title="mpython.core._DictMixin.deal" href="#mpython.core._DictMixin.deal">deal</a></code></li>
<li><code><a title="mpython.core._DictMixin.items" href="#mpython.core._DictMixin.items">items</a></code></li>
<li><code><a title="mpython.core._DictMixin.keys" href="#mpython.core._DictMixin.keys">keys</a></code></li>
<li><code><a title="mpython.core._DictMixin.setdefault" href="#mpython.core._DictMixin.setdefault">setdefault</a></code></li>
<li><code><a title="mpython.core._DictMixin.update" href="#mpython.core._DictMixin.update">update</a></code></li>
<li><code><a title="mpython.core._DictMixin.values" href="#mpython.core._DictMixin.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpython.core._ListMixin" href="#mpython.core._ListMixin">_ListMixin</a></code></h4>
<ul class="two-column">
<li><code><a title="mpython.core._ListMixin.count" href="#mpython.core._ListMixin.count">count</a></code></li>
<li><code><a title="mpython.core._ListMixin.index" href="#mpython.core._ListMixin.index">index</a></code></li>
<li><code><a title="mpython.core._ListMixin.insert" href="#mpython.core._ListMixin.insert">insert</a></code></li>
<li><code><a title="mpython.core._ListMixin.list_contains" href="#mpython.core._ListMixin.list_contains">list_contains</a></code></li>
<li><code><a title="mpython.core._ListMixin.pop" href="#mpython.core._ListMixin.pop">pop</a></code></li>
<li><code><a title="mpython.core._ListMixin.remove" href="#mpython.core._ListMixin.remove">remove</a></code></li>
<li><code><a title="mpython.core._ListMixin.reverse" href="#mpython.core._ListMixin.reverse">reverse</a></code></li>
<li><code><a title="mpython.core._ListMixin.sort" href="#mpython.core._ListMixin.sort">sort</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpython.core._ListishMixin" href="#mpython.core._ListishMixin">_ListishMixin</a></code></h4>
<ul class="">
<li><code><a title="mpython.core._ListishMixin.append" href="#mpython.core._ListishMixin.append">append</a></code></li>
<li><code><a title="mpython.core._ListishMixin.clear" href="#mpython.core._ListishMixin.clear">clear</a></code></li>
<li><code><a title="mpython.core._ListishMixin.extend" href="#mpython.core._ListishMixin.extend">extend</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpython.core._SparseMixin" href="#mpython.core._SparseMixin">_SparseMixin</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
